/*
* Arduinio sketch to demonstrate the interactive (via serial line) 
* setting and calibration of the PCF85063TP and the handling of interrupts
* generated by the RTC.
*
* Wiring:
* Arduino      PCF85063TP
* VCC  ------- VCC
* SCL  ------- SCL
* SDA  ------- SDA
* INT  ------- D3
* GND  ------- GND
*
* Arduino is connected to PC via USB-Serial at 57600 baud.
*
* Upon start, the Arduino is in 'RUN' mode and prints date and time 
* every second at USB-Serial.
*
* Enter the letter 'C' to get into command mode.
* Here you can set date and time with the command
* T YYYY-MM-DD hh:mm:ss
* e.g.
* T 2020-06-11 18:00:00
* 
* Optionally you may add an integer offset to the above command, e.g.
* T 2020-06-11 18:00:00 5
* The offset is the number of seconds per 24 hours that the clock goes wrong.
* If the clock is to slow, then offset < 0
* If the clock is to fast, then offset > 0
*
* You leave the command mode and get into 'RUN' mode again by
* entering the letter 'R'.
*
* The sketch demonstrates the usage of interrupts from the RTC.
* It generates an interrupt each minute, the sketch should then
* output *** Interrupt *** at the serial line.
* 
* Copyright 2020 Martin Kompf
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <Wire.h>
#include "PCF85063TP.h"

// Real time clock
PCD85063TP RTclock;
#define RTC_INT_PIN 3
volatile bool rtcIntFlag = 0;

// command line
#define MAX_CMD_LEN 80
char command[MAX_CMD_LEN]; // command buffer
int inCount = 0; // command buffer index
boolean cmdComplete = false;

// Mode of serial line: 
// C - command, R - run and display clock
char mode = 'R';


/* 
 * Display time on the serial monitor.
 */
void printTime() {
    RTclock.getTime();
    
    switch (RTclock.dayOfWeek) { // Friendly printout the weekday
        case MON:
            Serial.print("MON");
            break;
        case TUE:
            Serial.print("TUE");
            break;
        case WED:
            Serial.print("WED");
            break;
        case THU:
            Serial.print("THU");
            break;
        case FRI:
            Serial.print("FRI");
            break;
        case SAT:
            Serial.print("SAT");
            break;
        case SUN:
            Serial.print("SUN");
            break;
    }
    Serial.print(", ");
    
    Serial.print(RTclock.year + 2000, DEC);
    Serial.print("-");
    Serial.print(RTclock.month, DEC);
    Serial.print("-");
    Serial.print(RTclock.dayOfMonth, DEC);
    Serial.print(" ");
    Serial.print(RTclock.hour, DEC);
    Serial.print(":");
    Serial.print(RTclock.minute, DEC);
    Serial.print(":");
    Serial.println(RTclock.second, DEC);
}

void skipWhitespace(char **p) {
  while (**p != 0 && **p == ' ') {
    ++(*p);
  }
}

int parseAsInt(char **p, char delim) {
  char *q = *p + 1;
  while (*q != 0 && *q != delim) {
    ++q;
  }
  *q = 0;
  int value = atoi(*p);
  *p = q + 1;
  return value;
}

/**
 * Compute the day of week from year, month, and day of month.  
 * 1 <= m <= 12,  y > 1752 (in Europe) 
 */
int dayofweek(int y, int m, int d)   {
  static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
  y -= m < 3;
  return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;
}

/**
 * Set the time and date from the command line.
 * Expected format of command: T YYYY-MM-DD hh:mm:ss [offset]
 * e.g. T 2020-06-11 18:00:00
 * Optional offset is the number of seconds per 24 hours that the clock goes wrong.
 * If the RTC is to slow, then offset < 0
 * If the RTC is to fast, then offset > 0
 */
void setTimeFromCommandLine() {
  int year, month, day, hour, minute, second = -1;
  int offset = 0;
  bool has_offset = false;
  char *p = &command[1];
  skipWhitespace(&p);
  year = parseAsInt(&p, '-');
  month = parseAsInt(&p, '-');
  day = parseAsInt(&p, ' ');
  skipWhitespace(&p);
  hour = parseAsInt(&p, ':');
  minute = parseAsInt(&p, ':');
  second = parseAsInt(&p, ' ');
  // offset
  skipWhitespace(&p);
  if (*p != 0) {
    offset = parseAsInt(&p, ' ');
    has_offset = true;
  }

  if (year > 2000 && year < 2100 && month > 0 && month < 13 && day > 0 && day < 32
    && hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60) {
    
    RTclock.stopClock();
    RTclock.fillByYMD(year, month, day);
    RTclock.fillByHMS(hour, minute, second);
    RTclock.fillDayOfWeek(dayofweek(year, month, day));
    RTclock.setTime(); //write time to the RTC chip
    if (has_offset) {
      float offset_sec = (float) offset / 86400.0f;
      RTclock.calibratBySeconds(0, offset_sec);
    }
    RTclock.startClock();
      
    Serial.print("Date/time set to ");
    printTime();
    Serial.print("Calibration reg is ");
    Serial.println(RTclock.readCalibrationReg(), BIN);
  } else {
    Serial.println("Invalid date/time, required format is YYYY-MM-DD hh:mm:ss");
  }
}

/**
 * Read one line from serial connection and interpret it as a command
 */
void doCommand() {
  // clear command buffer
  memset(command, 0, MAX_CMD_LEN);
  inCount = 0;
  cmdComplete = false;
  // print prompt 
  Serial.print(">");
  while (! cmdComplete) {
    // read input
    while (Serial.available()) {
      // get the new byte:
      char inChar = (char)Serial.read();
      if (inChar == '\n' || inChar == '\r') {
        command[inCount] = 0;
        Serial.println();
        cmdComplete = true;
        break; // End of line
      } else if (inCount < MAX_CMD_LEN - 1) {
        command[inCount] = inChar;
        inCount++;
        // echo
        Serial.print(inChar);
      }
    }
  }
  
  // interprete command
  switch (command[0]) {
    case 'R':
      // start running
      mode = 'R';
      break;
    case 'T':
      // set time
      setTimeFromCommandLine();
      break;
  }
}

/**
 * Interrupt routine.
 * It is called when RTC sends minute (MI) interrupt.
 */
void clockMI() {
  rtcIntFlag = 1;
}

/**
 * Setup.
 */
void setup() {
  // initialize serial communications at 57600 bps:
  Serial.begin(57600);
  // initialize hardware
  RTclock.begin();
}

/**
 * Main loop.
 */
void loop() {
  if (mode == 'C') {
    // disable interrupt from RTC
    RTclock.setInterrupt(false, false);
    detachInterrupt(digitalPinToInterrupt(RTC_INT_PIN));
    doCommand();
  } else if (mode == 'R') {
    if (Serial.available()) {
      char inChar = (char)Serial.read();
      if (inChar == 'C') {
        // exit data mode
        mode = 'C';
      }
    }
  }
  if (mode == 'R') {
    // enable interrupt from RTC
    RTclock.setInterrupt(true, false);
    attachInterrupt(digitalPinToInterrupt(RTC_INT_PIN), clockMI, FALLING);
    // perform measurement
    // ...

    // for now, print the time to serial
    printTime();

    // check if an interrupt has occured
    if (rtcIntFlag) {
      rtcIntFlag = 0;
      Serial.println("*** Interrupt ***"); 
    }
  }
  delay(1000);              
}
